
# Controller to Authorization Server Interactions  
_(c) AMWA 2021, CC Attribution-NoDerivatives 4.0 International (CC BY-ND 4.0)_
## Overview
This section details the interactions between an NMOS Controller and the Authorization Server. These include:

 - **Discovery of the Authorization Server**
 - **Client Registration**: Registration of the NMOS Controller with the Authorization Server.
 - **Authentication Code Flow**: Request of an Access Token from the Authorization Server.
 - **Refreshing the Bearer Token**: Ensuring the token is always valid 

![Node to Authorization Interactions](./images/authorization_flow.png)

The sequence diagram above gives an overview of these interaction which are described in more detail below.
## Discovery of the Authorization Server
In order to interact with the Authorization Server, you need to know where it is.  IS-10 specifies that the [Authorization Server should use unicast DNS-SD](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/3.0._Discovery.html#dns-sd-advertisemen) to advertise itself to the  Node.

Once the controller knows the whereabouts of the Authorization Server it can then fetch the [Authorization Server Metadata](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/3.0._Discovery.html#authorization-server-metadata-endpoint) to obtain supported features and endpoints.

Example request to get server metadata:

```
GET /.well-known/oauth-authorization-server HTTP/1.1
Host: authorization-server.example.com
```
Example server metadata HTTP response:
```
HTTP/1.1 200 OK
Content-Type: application/json
```
```
{
  "authorization_endpoint": "https://authorization-server.example.com/authorize",
  "code_challenge_methods_supported": [
    "plain",
    "S256"
  ],
  "grant_types_supported": [
    "authorization_code",
    "implicit",
    "refresh_token",
    "password",
    "client_credentials"
  ],
  "issuer": "https://authorization-server.example.com",
  "jwks_uri": "https://authorization-server.example.com/jwks",
  "registration_endpoint": "https://authorization-server.example.com/register",
  "request_object_signing_alg_values_supported": [
    "PS384",
    "ES384",
    "RS384",
    "HS256",
    "HS512",
    "ES256",
    "RS256",
    "HS384",
    "ES512",
    "PS256",
    "PS512",
    "RS512",
    "none"
  ],
  "response_types_supported": [
    "code",
    "none",
    "token",
    "code token"
  ],
  "scopes_supported": [
    "channelmapping",
    "connection",
    "events",
    "node",
    "query",
    "registration"
  ],
  "token_endpoint": "https://authorization-server.example.com/token",
  "token_endpoint_auth_methods_supported": [
    "private_key_jwt",
    "client_secret_basic",
    "client_secret_post",
    "tls_client_auth",
    "client_secret_jwt"
  ],
  "token_endpoint_auth_signing_alg_values_supported": [
    "PS384",
    "ES384",
    "RS384",
    "HS256",
    "HS512",
    "ES256",
    "RS256",
    "HS384",
    "ES512",
    "PS256",
    "PS512",
    "RS512"
  ]
}
```
## Client Registration 
NMOS Controller normally built as a native application or a browser based application.  Both types in OAuth 2.0 are treated as [public clients](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.2._Behaviour_-_Clients.html#user-agent-based--browser-applications), it means they cannot securely store the Client Secret. OAuth 2.0 provides a special way on obtaining the access token, details will be described in the [Authorization Code Flow](4.3.%20Controller%20to%20Authorization%20Server%20Interactions.md#authentication-code-flow) section.

NMOS controller first needs to register with the Authorization Server. This is usually a one time operation that a Controller would typically perform when first activated on the network.

The registration is done via a [dynamic client registration](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.2._Behaviour_-_Clients.html#client-registration) with the Authorization Server. The registration includes the expected grant type, which should be set to  [authorization code grant](https://tools.ietf.org/html/rfc6749#section-4.1)

Depending on how the Authorization Server has been configured, it is likely that the Client Registration will need to be authenticated using an Initial Access Token.  This token will be generated by the Authentication Server, and provided to the NMOS Controller by some proprietary method. 

Example public client registration request including an Initial Access Token (This is the `Authorization: Bearer` in the HTTP header)

```
POST /register HTTP/1.1
Host: authorization-server.example.com
Content-Type: application/json
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCIg...
```
```
{
  "client_name": "My Example Controller",
  "grant_types": [
    "authorization_code",
    "refresh_token"
  ],
  "redirect_uris": [
    "https://controller.example.com/auth/callback"
  ],  
  "response_types": [
    "code"    
  ],
  "scope": "channelmapping connection events node query",
  "token_endpoint_auth_method": "none"
}
```
Example response:
```
HTTP/1.1 201 Created
Content-Type: application/json
```
```    	
{
  "client_id": "40baf617-1744-4c24-9baf-22351bec1a73",
  "client_name": "My Example Controller",
  "client_id_issued_at": 1611940142,
  "grant_types": [
    "authorization_code",
    "refresh_token"
  ],
  "redirect_uris": [
    "https://controller.example.com/auth/callback"
  ],
  "response_types": [
    "code"
  ],
  "token_endpoint_auth_method": "none"
}
```

## Authentication Code Flow
For overcoming the secret issue on [public client](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.2._Behaviour_-_Clients.html#user-agent-based--browser-applications), OAuth 2.0 provides a version of the Authorization Code Flow which makes use of a Proof Key for Code Exchange (PKCE) (defined in [OAuth 2.0 RFC 7636](https://tools.ietf.org/html/rfc7636)). The PKCE-enhanced Authorization Code Flow introduces a secret created by the calling application that can be verified by the authorization server; this secret is called the Code Verifier. Additionally, the controller creates a transform value of the Code Verifier called the Code Challenge and sends this value over HTTPS to retrieve an Authorization Code. This way, a malicious attacker can only intercept the Authorization Code, and they cannot exchange it for a token without the Code Verifier.

To start the authorization cod flow, controller creates a cryptographically-random [`code_verifier`](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.3._Behaviour_-_Token_Requests.html#authorization-request-and-response) and from this generates a [`code_challenge`](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.3._Behaviour_-_Token_Requests.html#authorization-request-and-response). Then redirects the controller operator to the Authorization Server ([`/authorize`  endpoint](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/2.0._APIs.html#authorization-endpoints) along with the `code_challenge`. 

Example request to get authorization code:
```
GET /token HTTP/1.1
Host: authorization-server.example.com
?client_id=30baf617-1744-4c24-9baf-22351bec1a73
&redirect_uri=https://controller.example.com/auth/callback
&response_type=code
&code_challenge=HbYjeCHvDfKpyYacEHKLdffF0geuyu3A-b4ir7ZG8-E
&code_challenge_method=S256
&state=ricgtUUXODcOzifiJDnOw25rZ8wTZCxU
&scope=channelmapping%20connection%20events%20node%20query
```
The Authorization Server redirects the controller operator to the login and authorization prompt.

Controller operator can then login and give consent on the Authorization Server for the controller.

Authorization Server redirects the 

In this request the `client_assertion` is a self signed JWT and `client_id` is the result from client registration.

a can now request an authorization code  bearer token from the Authorization Server using the [authentication codes flow](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/1.0._Overview.html#authorization-flow-informative). This access token will allow the Controller to authenticate API calls on other NMOS Nodes, for instance, the NMOS Registry.

Example request to get authorization code:

```
POST /token HTTP/1.1
Host: authorization-server.example.com
Content-Type: application/x-www-form-urlencoded
```
```
client_id=30baf617-1744-4c24-9baf-22351bec1a73
&redirect_uri=https://controller.example.com/auth/callback
&response_type=code
&code_challenge=HbYjeCHvDfKpyYacEHKLdffF0geuyu3A-b4ir7ZG8-E
&code_challenge_method=S256
&state=ricgtUUXODcOzifiJDnOw25rZ8wTZCxU
&scope=channelmapping connection events node query
```

In this request the `client_assertion` is a self signed JWT and `client_id` is the result from client registration.

Example token response:
```
HTTP/1.1 200 OK
Content-Type: application/json
```
```
{
  "access_token": "eyJhbGciOiJSUzUxMiIsInR5cCIgOiAiSl...",
  "expires_in": 180,
  "scope": "registration",
  "token_type": "bearer"
}
```

## Refreshing the Bearer Token
The Bearer Token has a limited life specified in seconds by the value of the `expires_in` parameter.  The Node should refresh the token before [it exceeds its half life](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.4._Behaviour_-_Access_Tokens.html#access-token-lifetime) (if the token lifetime is 30 seconds, then it should be refreshed at least 15 seconds before token expiry). 

[Add details of refreshing token]

## Fetch Authorization Server Public Keys
As well as acquiring a token to allow this Node to register, the Node will also need the [Authorization Server's public keys](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.5._Behaviour_-_Resource_Servers.html#public-keys) so that it can authenticate calls on its own APIs.  These keys should be fetched every hour to ensure the keys are always up to date.

Example request to get server public keys:
```
GET /jwks HTTP/1.1
Host: authorization-server.example.com
```
Example server public keys response:
```
HTTP/1.1 200 OK
Content-Type: application/json
```
```
[
  {
    "alg": "RS512",
    "e": "AQAB",
    "kid": "O4QEicS70s1DWFyt84niI80Z2SLsdNrVyeGwJe8g8qw",
    "kty": "RSA",
    "n": "yeSbbHw18xN3hh_VeHpSI01Fcp0xaI1znmWBVkm...",
    "use": "sig",
    "x5c": [
      "MIIFlTCCA32gAwIBAgICEAAwDQYJKoZIhvcNAQ..."
    ],
    "x5t": "LD3awp-sYoVbcfwOgB9BRO4HFYQ",
    "x5t#S256": "yCrclAKahB6SE68rbx5cRwuBZoeTXfW9smoLgt6u9t4"
  }
]
```
Note that if a Node is unable to contact an Authorization Server, it should attempt to contact another Authorization Server from the discovered list until this [either succeeds or the list is exhausted](https://specs.amwa.tv/is-10/branches/v1.0-dev/docs/4.5._Behaviour_-_Resource_Servers.html#public-keys). 
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTIwMjU4OTEyMCwtMTM2NDcyMjAzMCw0NT
IwMTg4NjIsLTEwMjkzMDUzNTEsMzA1MDY2MTc4LDQ1MTM2ODA4
MSwxNTAzMzM0NzIwXX0=
-->